<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>排序 | Viyu</title>
  <meta name="author" content="Viyu">
  
  <meta name="description" content="【选择排序】
a[i++] —&gt; a[n]，从前往后看、选择最小值、一次交换到位
1，完整循环找到数组中最小的元素；
2，把这个最小的元素与a[0]交换；
3，在a[i]-a[n](i = 1, 2, … n)的子数组中重复1-2步骤；
1
2
3
4
5
6
7
8
9
10
11
12
13
14
for(int i = 0; i &lt; n; i++) {

    int min = i;

    for(int j = i + 1; j &lt; n; j++) {

        if(a[j] &lt; min) 

            min = j;

    }

    swap(i, j, a);
}



简写：
1
2
3
4
5
for(int i =0; i &lt; n; i++) {
    min = //本次循环的i...n中的最小的元素的index；

    //将min和本次循环的i两个元素交换；
}">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="排序"/>
  <meta property="og:site_name" content="Viyu"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Viyu" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Viyu</a></h1>
  <h2><a href="/">Viyu's Blog</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2010-02-05T00:00:00.000Z"><a href="/2010/02/05/2010-02-05-sort/">Feb 5 2010</a></time>
      
      
  
    <h1 class="title">排序</h1>
  

    </header>
    <div class="entry">
      
        <p><b>【选择排序】</b></p>
<p>a[i++] —&gt; a[n]，从前往后看、选择最小值、一次交换到位</p>
<p>1，完整循环找到数组中最小的元素；</p>
<p>2，把这个最小的元素与a[0]交换；</p>
<p>3，在a[i]-a[n](i = 1, 2, … n)的子数组中重复1-2步骤；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="function"><span class="title">for</span><span class="params">(int i = <span class="number">0</span>; i &lt; n; i++)</span> {

    <span class="title">int</span> <span class="title">min</span> = <span class="title">i</span>;

    <span class="title">for</span><span class="params">(int j = i + <span class="number">1</span>; j &lt; n; j++)</span> {

        <span class="title">if</span><span class="params">(a[j] &lt; min)</span> 

            <span class="title">min</span> = <span class="title">j</span>;

    }

    <span class="title">swap</span><span class="params">(i, j, a)</span>;
}
</pre></td></tr></table></figure>


<p>简写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++) {
    <span class="built_in">min</span> = <span class="comment">//本次循环的i...n中的最小的元素的index；</span>

    <span class="comment">//将min和本次循环的i两个元素交换；</span>
}
</pre></td></tr></table></figure>


<a id="more"></a>

<p>特点：</p>
<p>选择排序的扫描路线：a[i++] —&gt; a[n]</p>
<p>选择排序是在每个大循环下，通过完整子循环找到最小值后，退出子循环再进行交换，而不是一找到小于关系就交换，每次交换后，左侧的有序数组的位置是最终的；</p>
<p>运行时间和输入无关，扫描数组的次数是固定的，因为大循环和子循环的次数是固定的，前一次扫描并不为下一次扫描提供信息；</p>
<p>交换次数最少，因为是子循环完全结束后才进行一次交换，每次交换的结果都是最后的排序子结果，元素不用做二次挪动；</p>
<p>选择排序是一截一截往后看，将子数组中的最小元素交换到最前头的位置；</p>
<p>选择排序没有最好情况和最坏情况，扫描的次数是固定的，交换的次数已经是所有排序算法中最少的了；</p>
<hr>
<p><b>【插入排序】</b></p>
<p>a[j—] —&gt; a[0]，从半路往前看、让元素尝试往前走不动为止</p>
<p>插入排序是一截一截往前看，将倒置的元素交换；对于一个元素，总是尝试往前走，走到不能走为止，因为前面的元素已然有序了，所以走不动的时候左侧元素也是刚刚重新有序；总是相邻元素交换，所以交换次数频繁，一次交换的位置未必是最终位置；</p>
<p>插入排序的扫描路线：a[j—] —&gt; a[0]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="title">for</span><span class="params">(int i = <span class="number">1</span>; i &lt; n; i++)</span> {

    <span class="title">for</span><span class="params">(int j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j] &lt; a[j-<span class="number">1</span>]; j--)</span> 

        <span class="title">swap</span><span class="params">(j, j -<span class="number">1</span>, a)</span>;
}
</pre></td></tr></table></figure>


<p>每次子循环的结果，左侧的元素肯定是在已知（已经扫描）的数组中有序的，所以每次子循环发生的条件是，如果a[j]小于a[j-1]，则交换，然后继续进行j—之后的扫描；但如果a[j]不小于a[j-1]，因为左侧在已知数组中是有序的，这个时候该子循环就不会发生了；</p>
<p>对已然有序的数组排序，插入排序是线性扫描，0次交换；</p>
<p>插入排序就是解决倒置的两个元素，交换的次数就是倒置的元素个数；</p>
<p>插入排序和选择排序都是平方级的运行时间，但插入排序通常比选择排序快一个常数，因为对于随机的数组来说，插入排序扫描的次数会由于数组中的部分有序而减少，但选择排序不会，必须全扫描；交换，则是插入排序比选择排序次数要多，选择排序交换次数最多不超过n;</p>
<hr>
<p><b>【归并排序】</b></p>
<p>先2分排序子数组，再归并成原数组</p>
<p>原地归并算法：</p>
<p>1，先将所有元素赋值到一个新的数组中，此时数组是两截有序的数组；</p>
<p>2， 在原数组上讲新数组中的数本地归并回来：左边用尽取右边；右边用尽取左边；右边当前元素比左边小取右边；右边当前元素大于等于左边取左边；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>void merge(Comparable[] a, <span class="built_in">int</span> low, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> hign) {

    <span class="built_in">int</span> i = low, j = <span class="built_in">mid</span> + <span class="number">1</span>;

    <span class="keyword">for</span>(<span class="built_in">int</span> k = low; k &lt;= hign; k++) 

        aux[k] = a[k];

    <span class="keyword">for</span>(<span class="built_in">int</span> k = low; k &lt;= hign; k++) 

        <span class="keyword">if</span>(i &gt; <span class="built_in">mid</span>)                     a[k] = aux[j++];

        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hign)            a[k] = aux[i++];

        <span class="keyword">else</span> <span class="keyword">if</span>(aux[j] &lt; aux[i])    a[k] = aux[j++);

        <span class="keyword">else</span>                                  a[k] = aux[i++];
}
</pre></td></tr></table></figure>


<p>自顶向下的归并排序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="function"><span class="title">sort</span><span class="params">(a, <span class="number">0</span>, a.length - <span class="number">1</span>)</span>;

<span class="title">void</span> <span class="title">sort</span><span class="params">(<span class="variable">Comparable</span>[] a, int low, int hign)</span> {

    <span class="title">if</span><span class="params">(hign &lt; = low)</span>        <span class="title">return</span>;

    <span class="title">int</span> <span class="title">mid</span> = <span class="title">low</span> + <span class="params">(hign - low)</span> / 2;

    <span class="title">sort</span><span class="params">(a, low, mid)</span>;

    <span class="title">sort</span><span class="params">(a, mid + <span class="number">1</span>, hign)</span>;

    <span class="title">merge</span><span class="params">(a, low, mid, hign)</span>;
}
</pre></td></tr></table></figure>


<p>归并算法的思路就是：两个单元素的数组是分别有序的，可以通过merge方法将其归并为一个2元素的有序数组，依此类推，两个a[low]到a[mid]和a[mid+1]到a[hign]的数组分别有序，可以通过merge方法将其归并为一个有序数组a[low]到a[hign]；</p>
<p>归并自上而下，先分拆(sort)直至单元素数组，再归并(merge)回到原数组；</p>
<p>归并算法的几个优化策略：</p>
<p>1，对小规模数组改用插入排序，比如sort方法中发现hign - low &lt;= 10，则用插入排序；</p>
<p>2， 测试数组是否已经有序，就是看a[mid]如果小于等于a[mid+1]，就不用归并了；</p>
<p>归并排序的时间总是NlogN；</p>
<p>跟普通排序不需要额外空间不一样，归并排序是需要额外空间的，跟N成正比；</p>
<p>归并排序是某种程度上的空间换时间算法；</p>
<p>自底向上的归并：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">void</span> <span class="comment">sort(Comparable</span>[<span class="title">]</span> <span class="comment">a)</span> <span class="comment">{</span>

    <span class="comment">aux</span> <span class="comment">=</span> <span class="comment">new</span> <span class="comment">Comparable</span>[<span class="comment">a</span>.<span class="comment">length</span>]<span class="comment">;</span>

    <span class="comment">for(int</span> <span class="comment">sz</span> <span class="comment">=</span> <span class="comment">1;</span> <span class="comment">sz</span> &lt; <span class="comment">a</span>.<span class="comment">length;</span> <span class="comment">sz</span> <span class="comment">=</span> <span class="comment">sz</span> <span class="literal">+</span> <span class="comment">sz)</span> 

        <span class="comment">for(int</span> <span class="comment">low</span> <span class="comment">=</span> <span class="comment">0;</span> <span class="comment">low</span> &lt; <span class="comment">N</span> <span class="literal">-</span> <span class="comment">sz;</span> <span class="comment">low</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">sz</span> <span class="literal">+</span> <span class="comment">sz)</span> 

            <span class="comment">merge(a</span>, <span class="comment">low</span>, <span class="comment">low</span> <span class="literal">+</span> <span class="comment">sz</span> <span class="literal">-</span> <span class="comment">1</span>, <span class="comment">Math</span>.<span class="comment">min(low</span> <span class="literal">+</span> <span class="comment">sz</span> <span class="literal">+</span> <span class="comment">sz</span> <span class="literal">-</span> <span class="comment">1</span>, <span class="comment">N</span> <span class="literal">-</span><span class="comment">1);</span>
<span class="comment">}
</pre></td></tr></table></figure>


<p>自顶向下是 化整为零，自底向上是循序渐进；</p>
<p>归并排序用了aux辅助数组，是空间复杂度不是最优的；</p>
<p>任何比较排序算法的复杂度都不会低于lg(N!)~NlgN；</p>
<hr>
<p><b>【快速排序】</b></p>
<p>每一次切分都使数组左右两边趋于有序</p>
<p>特点：</p>
<p>1， 快速排序是原地排序，只需要一个很小的辅助栈；归并排序无法做到；</p>
<p>2， 复杂度是NlgN；插入、选择等交换排序无法做到；</p>
<p>3， 快速排序的原理：将一个数组分成两个子数组，将两部分独立地排序。</p>
<p>快速排序和归并排序是互补的：</p>
<p>1， 归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；快速排序是当两个子数组都有序时整个数组也就自然有序了。</p>
<p>2， 归并排序中，递归调用发生在处理整个数组之前；快速排序中，递归调用发生在处理整个数组之后；</p>
<p>3， 归并排序是数组被等分为两半；快速排序中，切分的位置取决于数组的内容；</p>
<p>算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>void <span class="keyword">sort</span>(Comparable[] a) {

    random(a) <span class="comment">//随机打乱数组，为了比避免每次的切分元素总是子数组中的最小元素</span>

    <span class="keyword">sort</span>(a, <span class="number">0</span>, a.length - <span class="number">1</span>);

}

void <span class="keyword">sort</span>(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign) {

    <span class="keyword">if</span>(hign &lt;= low)

        <span class="keyword">return</span>;

    <span class="keyword">int</span> j = <span class="keyword">partition</span>(a, low, hign);

    <span class="keyword">sort</span>(a, low, j -<span class="number">1</span>);

    <span class="keyword">sort</span>(a, j + <span class="number">1</span>, hign);
}
</pre></td></tr></table></figure>


<p>递归调用切分实现排序的思路：</p>
<p>如果左子数组和右子数组都是有序的，那么由左子数组（有序且所有元素都小于等于切分元素+切分元素+右子数组（有序且所有元素大于等于切分元素）组成的结果数组也一定是有序的；</p>
<p>切分找j的条件</p>
<p>1， 对于某个j，a[j]已经排定；</p>
<p>2， a[low]到a[j - 1]中的所有元素都不大于a[j]；</p>
<p>3， a[j+1]到a[hign]中的所有元素都不小于a[j]；</p>
<p>注意，上面的2， 3说的都是j的左边和右边的元素分别不大于和不小于切分元素，但此时左右两边并不是有序的；</p>
<p>切分算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">int</span> partition(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign) {

    <span class="keyword">int</span> i = low, j = hign + <span class="number">1</span>;

    Comparable v = a[<span class="number">0</span>];

    <span class="keyword">while</span>(<span class="keyword">true</span>) {

        <span class="keyword">while</span>(a[++i]  &lt; v)

            <span class="keyword">if</span>(i == hign)

                    <span class="keyword">break</span>;

        <span class="keyword">while</span>(a[--j] &gt; v)

            <span class="keyword">if</span>(j == low)

                <span class="keyword">break</span>;

        <span class="keyword">if</span>(i &gt;= j)

            <span class="keyword">break</span>;

        swap(a, i, j);

    }

    swap(a, low, j);

    <span class="keyword">return</span> j;
}
</pre></td></tr></table></figure>


<p>两个小while分别做从左、从右往中间走的动作；</p>
<p>从左边走遇见的比切分元素大的元素，跟从右边走遇见的比切分元素小的元素，交换之;</p>
<p>因为一次大循环中用的都是a[lo]，同一个参考值，那么通过这样的交换，左侧都小，右侧都大;</p>
<p>i, j相遇的最后一次交换，是a[j]被认为小小于切分元素，a[i]被认为大于切分元素，然后他们交换了位置，这一次是相邻交换，—j和—i使得i和j的索引也交换了，所以此时j就是上一次的i的位置，已经被小于切分元素a[lo]的上一次的a[j]给占用了；同时a[i]则是 大于a[lo]的元素；</p>
<p>所以，最后swap(lo, j)，跟开始的切分元素=a[lo]相呼应；</p>
<p>切分的轨迹是这样的 ：</p>
<p>lo….i….j…hi</p>
<p>lo….ij…….hi</p>
<p>lo….ji…….hi</p>
<p>j…..loi…….hi</p>
<p>归并排序是从底往上一层层合并有有序子数组；</p>
<p>快速排序是从上往下，循序渐进，一层层切分下去，每一次切分都使得数组呈两边大小合适状态，切到单元素数组的时候，整个数组基于n多个两边大小合适的小数组，而有序了；</p>
<p>切分元素不一定要选择a[low]，随机选都行；</p>
<p>打乱数组顺序的意义：random(a) //随机打乱数组，为了比避免每次的切分元素总是子数组中的最小元素。</p>
<p>如果每次的切分元素总是最小的元素，那么每一次切分都只是分离成一个元素的数组和一个N-1长度的子数组，这使得数组会被切分N多次；</p>
<p>对于小数组，切换到插入排序能提高效率；</p>
<p>partition方法还可以用来找一个数组中【第k大的元素】：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>int lo = <span class="number">0</span>, hi = a.length - <span class="number">1</span>;

<span class="function"><span class="title">while</span><span class="params">(hi &gt; lo)</span> {

    <span class="title">int</span> <span class="title">j</span> = <span class="title">partition</span><span class="params">(a, lo, hi)</span>;

    <span class="title">if</span><span class="params">(j == k)</span>

        <span class="title">return</span> <span class="title">a</span>[<span class="title">k</span>];

    <span class="title">if</span><span class="params">(j &gt; k)</span>

        <span class="title">hi</span> = <span class="title">j</span> - 1;

    <span class="title">if</span><span class="params">(j &lt; k)</span>

        <span class="title">lo</span> = <span class="title">j</span> + 1;

    <span class="title">return</span> <span class="title">a</span>[<span class="title">k</span>];
</pre></td></tr></table></figure>


<hr>
<p><b>【堆排序】</b></p>
<p>先使堆有序，再一个个删除最大值，删除即把第一个最大元素往尾部交换以推出堆</p>
<p>上浮和下沉算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="keyword">void</span> swim(<span class="keyword">int</span> k) {

    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; pq[k/<span class="number">2</span>] &lt; pq[k]) {

        swap(pq, k/<span class="number">2</span>, k);

        k = k / <span class="number">2</span>;
}

<span class="keyword">void</span> sink(<span class="keyword">int</span> k) {

    <span class="keyword">while</span>(<span class="number">2</span> * k &lt;= N) {
        <span class="keyword">int</span> j = <span class="number">2</span> * k;

        <span class="keyword">if</span>(j &lt; N &amp;&amp; pq[j] &lt; pq[j+<span class="number">1</span>]) <span class="comment">//选取两个子节点中较大的一个往上交换</span>

                j++;

        <span class="keyword">if</span>(pq[k] &gt;= pq[j])   <span class="comment">//结束下沉，已经比字节点大了</span>

                <span class="keyword">break</span>;

        swap(pq, k, j); <span class="comment">//下沉</span>

        k = j;

}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sort(Comparable[] a) {

    <span class="keyword">int</span> N = a<span class="variable">.length</span>;

    <span class="comment">//先使得堆有序</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)  <span class="comment">//从右到左扫，因为最终堆有序是右边总比左边小；</span>

            sink(a, k, N);             <span class="comment">//只扫描一半，因为一半之后的元素都是叶节点，就是为1的堆</span>

    <span class="comment">//再进行下沉排序，销毁堆有序</span>

   <span class="keyword">while</span>(N &gt; <span class="number">1</span>) {      <span class="comment">//把最大元素删除，然后放入堆缩小后数组中空出的位置</span>
        swap(a, <span class="number">1</span>, N--); <span class="comment">//a[1]就是最大元素，把其交换到最后一个，就是从堆有序堆中删除它</span>

        sink(a, <span class="number">1</span>, N);  <span class="comment">//被交换到a[1]的元素，通过在子堆中下沉，使得子堆再次有序</span>

}                           <span class="comment">//重复这个过程，最大元素总是往后一个一个走，最后整个数组就有序了</span>
</pre></td></tr></table></figure>



<p>堆排序的复杂度：N*lgN，而且是原地排序，无额外空间消耗；</p>
<hr>
<p><b>【SpaceToTime排序 空间换时间排序法】</b></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">int</span> i = <span class="number">0</span>;

<span class="keyword">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];

<span class="keyword">int</span> len = <span class="built_in">array</span>.length;

<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)  <span class="comment">//找出最大值，做为空间数组的length</span>

    <span class="keyword">if</span>(<span class="built_in">array</span>[i] &gt; max)

        max = <span class="built_in">array</span>[i];

<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];

<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)

    temp[<span class="built_in">array</span>[i]] = <span class="built_in">array</span>[i];

<span class="keyword">int</span> j = <span class="number">0</span>;

<span class="keyword">int</span> max1 = max + <span class="number">1</span>;

<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; max1; i++) {

    <span class="keyword">if</span>(temp[i] &gt; <span class="number">0</span>]

        <span class="built_in">array</span>[j++] = temp[i];
}

不计空间成本，把数组值映射到一个临时数组的下标，然后遍历临时数组，把大于<span class="number">0</span>的数顺序放回原数组；

注：temp[i] = i;

<span class="built_in">array</span>[i] &gt; <span class="number">0</span>;
</pre></td></tr></table></figure>


<hr>
<p><b>【Java.util.Arrays.sort】</b></p>
<p>对原始类型用三向切分的快速排序；</p>
<p>对引用类型用归并排序；</p>
<hr>
<p><b>【Comparable Comparator】</b></p>
<p>一个类实现了Comparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。<br>Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用：<br>1、类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身<br>2、可以使用多种排序标准，比如升序、降序等</p>
<p>多键排序，用Comparator；</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/Algorithm/">Algorithm</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://mosthink.net/2010/02/05/2010-02-05-sort/" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:mosthink.net">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Algorithm/">Algorithm</a><small>2</small></li>
  
    <li><a href="/tags/Android/">Android</a><small>7</small></li>
  
    <li><a href="/tags/Annotation/">Annotation</a><small>1</small></li>
  
    <li><a href="/tags/Class/">Class</a><small>1</small></li>
  
    <li><a href="/tags/Concurrence/">Concurrence</a><small>1</small></li>
  
    <li><a href="/tags/Design/">Design</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>3</small></li>
  
    <li><a href="/tags/Jvm/">Jvm</a><small>1</small></li>
  
    <li><a href="/tags/javascript/">javascript</a><small>1</small></li>
  
  </ul>
</div>


  <div class="search">
  <a href="http://info.flagcounter.com/yHDb"><img src="http://s11.flagcounter.com/map/yHDb/size_s/txt_000000/border_CCCCCC/pageviews_0/viewers_0/flags_0/" alt="Flag Counter" border="0"></a>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 Viyu
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>