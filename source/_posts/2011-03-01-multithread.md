title: 并发和多线程
date: 2011-03-01
tags: Concurrence
---
<b>线程安全性的需求不一定来自于对线程的直接使用，而是来源于对比如Servlet这种框架的使用</B>

无状态对象一定是线程安全的；有状态但是状态对象是线程安全的，比如是原子的，也是线程安全的。但如果有多个状态对象，则线程不安全，除非在一个原子操作中同时更新了所有状态对象。synchronized(obj){}就可以保证代码块的原子性。如果一个线程试图获取被另一个线程池有的锁，则该线程会阻塞；如果一个线程试图获取已经被自己池有的锁，“重入”机制使得该线程可以获取；

{% code %}
public class Widget {

public synchronized void dosth() {
}

}

public class Loggingwidget extends Widget {

public synchronized void dosth() {

System.out.println("do sth");

super.dosht();

}
}
{% endcode %}

---------------------------------------------------

<b>某个线程获得对象的锁之后，只能阻止其他线程获得同一个锁，并不能阻止其他线程通过另外的锁来访问对象的变量</b>

每个可变或共享的变量都该由同一个锁来保护；

简单粗暴的全部synchronized会使得并发程序变成串行程序，影响性能，多核CPU会有空载运行，应该缩小同步块的大小，将不影响共享状态并且执行时间较长的操作从同步代码块中分离出去。

简单性（对整个方法同步）与并发性（对尽可能短的代码路径进行同步）之间的平衡；

当执行较长时间或无法快速完成的操作时，比如网络I/O，一定不要持有锁，不然会影响活跃性和性能。

<!-- more -->

---------------------------------------------------

<b>并发关注的就是：共享+可变的状态</b>

多个线程之间，不仅要防止错误地修改和读取了状态，还要共享状态，即一个线程修改了状态，另一个线程要被通知到这个修改；

重排序：无同步的多线程程序中，无法正确判断代码的执行顺序。

Sleep和Yield都是让cpu不让锁，跟锁没关系；Wait是让锁。

非volatile的long和double不是线程安全的，64位的读写会被分解，不是原子性的；

“加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读写操作的线程都必须在同一锁上同步。”

---------------------------------------------------

<b>volatile是比synchronized更轻量级的同步</b>

olatile，确保将变量的更新操作通知到其他线程；

从内存可见性的角度，写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块。

加锁既可以保证可见性又可确保原子性，而volatile只确保可见性；

---------------------------------------------------

<b>逸出</b>

{% code %}
private String[] strs = {"Hello", "World"};

public String getStrs() {

return this.strs;
}
{% endcode %}

strs是被设计为private的，但是通过getStrs方法，外部类可以修改strs的内容，这就是逸出。

不要再构造过程中使thisy引用逸出:

{% code %}
public class ThisEscape {

public ThisEscape(EventSource source) {

    source.registerListener() { new EventListener() {

        public void onEvent(Event e) {

        }
...
{% endcode %}

上面的内部类把尚未构造完成的this给逸出了；

在构造方法中使用内部类，会逸出this;

在构造方法中启动线程，会逸出this;

在构造方法中调用可改写的实例方法（非private非final），会逸出this；

---------------------------------------------------

<b>调用栈和线程</b>

基本类型的局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这些栈；非基本类型的局部变量，可能被各种方式逸出，比如把该非基本类型的局部变量传递给其他的方法，而基本类型是无法被引用的，所以不会被逸出；

而全局变量，是被每一个线程-调用栈，共享的；

---------------------------------------------------

除非需要更高的可见性，否则应将所有的域都声明为私有域；

除非需要某个域是可变的，否则应将其声明为final域；

某种情况下，volatile+不可变对象，保证了原子性和可见性，

volatile保证可见性不保证原子性，而不可变对象保证了一种弱于synchronized的原子性；

当对象的引用对所有访问该对象的线程是可见时，对象发布时的状态对于所有线程也将是可见的；
